# 상품 목록 중복 제거

## 📋 문제 상황

라이브 방송 상세 조회 페이지의 **상품 목록** 섹션에서 동일한 상품이 여러 번 중복되어 표시되는 문제가 발생했습니다.

### 증상
- 상품 목록 숫자: 8개
- 실제 표시: 동일한 상품 정보가 8번 반복 표시
- 상품명, SKU, 옵션, 가격이 모두 동일한 상품이 중복됨

### 원인
- 데이터베이스의 `live_products` 테이블에 동일한 상품이 중복 저장됨
- 백엔드에서 중복 제거 로직 없이 그대로 반환
- 크롤러에서 상품 데이터 수집 시 중복 체크 미흡

## ✅ 해결 방법

### 백엔드 중복 제거 로직 추가

상품 데이터를 반환하기 전에 중복을 제거하는 로직을 추가했습니다.

#### 중복 판단 기준
다음 필드들이 모두 동일한 경우 중복으로 판단:
1. `product_id` - 상품 ID
2. `sku` - 상품 코드
3. `product_name` - 상품명
4. `option_name` - 옵션명
5. `original_price` - 원가
6. `sale_price` - 판매가
7. `discount_rate` - 할인율

#### 구현 코드

```javascript
// 상품 중복 제거 로직
// 같은 상품 (product_id, sku, product_name, option_name이 모두 동일)인 경우 하나만 남김
const _v_unique_products = [];
const _v_product_keys = new Set();

if (_v_products && Array.isArray(_v_products)) {
  for (const _v_product of _v_products) {
    // 중복 체크를 위한 고유 키 생성
    // product_id, sku, product_name, option_name을 조합하여 고유 키 생성
    const _v_unique_key = [
      _v_product.product_id || '',
      _v_product.sku || '',
      _v_product.product_name || '',
      _v_product.option_name || '',
      _v_product.original_price || '',
      _v_product.sale_price || '',
      _v_product.discount_rate || ''
    ].join('|');
    
    // 중복되지 않은 경우에만 추가
    if (!_v_product_keys.has(_v_unique_key)) {
      _v_product_keys.add(_v_unique_key);
      _v_unique_products.push(_v_product);
    }
  }
}
```

#### 로깅 개선

중복 제거 결과를 로그에 기록하여 모니터링 가능:

```javascript
logger.info('관련 데이터 조회 완료:', {
  products_raw: _v_products?.length || 0,              // 원본 상품 수
  products_unique: _v_unique_products.length,          // 중복 제거 후 상품 수
  products_duplicates_removed: (_v_products?.length || 0) - _v_unique_products.length,  // 제거된 중복 수
  // ... 기타 정보
});
```

## 🔧 기술적 세부사항

### 1. Set 자료구조 사용
- JavaScript의 `Set`을 사용하여 O(1) 시간 복잡도로 중복 체크
- 메모리 효율적이고 빠른 성능

### 2. 고유 키 생성 전략
- 여러 필드를 파이프(`|`)로 구분하여 고유 키 생성
- 빈 값은 빈 문자열로 처리하여 null/undefined 안전성 확보
- 모든 필드가 일치해야 중복으로 판단

### 3. 순서 보장
- 원본 데이터의 순서를 유지 (첫 번째 등장한 상품만 유지)
- `product_order` 필드에 따른 정렬 순서 보존

## 📊 예상 결과

### 개선 전
```
상품 목록 (8개)
1. 슈퍼 바이탈 에센스 - SKU: IOPE-SV-001
2. 슈퍼 바이탈 에센스 - SKU: IOPE-SV-001  ← 중복
3. 슈퍼 바이탈 에센스 - SKU: IOPE-SV-001  ← 중복
4. 슈퍼 바이탈 에센스 - SKU: IOPE-SV-001  ← 중복
5. 슈퍼 바이탈 에센스 - SKU: IOPE-SV-001  ← 중복
6. 슈퍼 바이탈 에센스 - SKU: IOPE-SV-001  ← 중복
7. 슈퍼 바이탈 에센스 - SKU: IOPE-SV-001  ← 중복
8. 슈퍼 바이탈 에센스 - SKU: IOPE-SV-001  ← 중복
```

### 개선 후
```
상품 목록 (1개)
1. 슈퍼 바이탈 에센스 - SKU: IOPE-SV-001
```

## 🚀 배포 방법

### 백엔드 재시작
```bash
cd backend
pkill -f "node.*src/server.js"
node src/server.js &
```

### 확인 방법
1. 라이브 방송 목록 페이지 접속
2. 상품이 중복되어 있던 라이브 방송 클릭
3. "상품 목록" 탭 확인
4. 중복된 상품이 제거되고 고유한 상품만 표시되는지 확인

### 로그 확인
```bash
# 백엔드 로그에서 중복 제거 결과 확인
tail -f backend/logs/combined.log | grep "products_duplicates_removed"
```

예시 로그:
```
products_raw: 8
products_unique: 1
products_duplicates_removed: 7
```

## 📝 추가 개선 사항

### 1. 크롤러 단계에서 중복 방지
현재는 백엔드에서 중복을 제거하지만, 근본적으로는 크롤러 단계에서 중복 데이터가 저장되지 않도록 개선 필요:

```python
# crawler/crawlers/naver_shopping_live.py
def save_products(live_id, products):
    """상품 데이터 저장 시 중복 체크"""
    for product in products:
        # 기존 상품 존재 여부 확인
        existing = supabase.table('live_products') \
            .select('product_id') \
            .eq('live_id', live_id) \
            .eq('sku', product['sku']) \
            .eq('product_name', product['product_name']) \
            .eq('option_name', product.get('option_name', '')) \
            .execute()
        
        # 중복이 없는 경우에만 저장
        if not existing.data:
            supabase.table('live_products').insert(product).execute()
```

### 2. 데이터베이스 UNIQUE 제약조건
`live_products` 테이블에 UNIQUE 제약조건 추가:

```sql
-- live_products 테이블에 복합 UNIQUE 제약조건 추가
ALTER TABLE live_products
ADD CONSTRAINT unique_product_per_live
UNIQUE (live_id, sku, product_name, option_name);
```

### 3. 중복 데이터 정리 스크립트
기존에 저장된 중복 데이터를 정리하는 스크립트:

```javascript
// scripts/cleanup-duplicate-products.js
async function cleanupDuplicateProducts() {
  // 모든 라이브 방송 조회
  const { data: lives } = await supabase
    .from('live_broadcasts')
    .select('live_id');
  
  for (const live of lives) {
    // 각 라이브의 상품 조회
    const { data: products } = await supabase
      .from('live_products')
      .select('*')
      .eq('live_id', live.live_id)
      .order('created_at', { ascending: true });
    
    // 중복 제거 (첫 번째 것만 유지)
    const uniqueProducts = new Map();
    const duplicateIds = [];
    
    for (const product of products) {
      const key = `${product.sku}|${product.product_name}|${product.option_name}`;
      
      if (uniqueProducts.has(key)) {
        duplicateIds.push(product.product_id);
      } else {
        uniqueProducts.set(key, product);
      }
    }
    
    // 중복 데이터 삭제
    if (duplicateIds.length > 0) {
      await supabase
        .from('live_products')
        .delete()
        .in('product_id', duplicateIds);
      
      console.log(`Live ${live.live_id}: ${duplicateIds.length}개 중복 제거`);
    }
  }
}
```

### 4. 상품 수량 집계
같은 상품이 여러 번 등장하는 경우, 수량을 합산하여 표시:

```javascript
// 같은 상품의 수량을 합산
const _v_aggregated_products = [];
const _v_product_map = new Map();

for (const _v_product of _v_products) {
  const _v_key = `${_v_product.sku}|${_v_product.product_name}`;
  
  if (_v_product_map.has(_v_key)) {
    // 기존 상품의 수량 증가
    const _v_existing = _v_product_map.get(_v_key);
    _v_existing.quantity = (_v_existing.quantity || 1) + (_v_product.quantity || 1);
  } else {
    // 새 상품 추가
    _v_product_map.set(_v_key, { ..._v_product, quantity: _v_product.quantity || 1 });
  }
}

_v_aggregated_products = Array.from(_v_product_map.values());
```

### 5. 프론트엔드 필터링 (백업)
백엔드에서 중복이 제거되지 않은 경우를 대비한 프론트엔드 필터링:

```javascript
// frontend/src/pages/LiveBroadcastDetail.jsx
const uniqueProducts = useMemo(() => {
  if (!liveData.products) return [];
  
  const seen = new Set();
  return liveData.products.filter(product => {
    const key = `${product.product_id}|${product.sku}|${product.product_name}|${product.option_name}`;
    if (seen.has(key)) return false;
    seen.add(key);
    return true;
  });
}, [liveData.products]);
```

## 🎯 기대 효과

1. **정확한 정보 제공**: 중복 없이 실제 상품 목록만 표시
2. **사용자 경험 개선**: 혼란스러운 중복 정보 제거
3. **데이터 신뢰성 향상**: 정확한 상품 수 표시
4. **성능 개선**: 불필요한 중복 데이터 전송 감소
5. **유지보수 용이**: 명확한 중복 제거 로직

## 📁 수정된 파일

- `/backend/src/services/eventService.js` (상품 중복 제거 로직 추가)

## 🔍 테스트 시나리오

### 1. 중복 상품이 있는 경우
- **입력**: 동일한 상품 8개
- **출력**: 고유한 상품 1개
- **로그**: `products_duplicates_removed: 7`

### 2. 중복 상품이 없는 경우
- **입력**: 서로 다른 상품 5개
- **출력**: 5개 상품 그대로
- **로그**: `products_duplicates_removed: 0`

### 3. 부분 중복이 있는 경우
- **입력**: 상품 A 3개, 상품 B 2개, 상품 C 1개
- **출력**: 상품 A 1개, 상품 B 1개, 상품 C 1개
- **로그**: `products_duplicates_removed: 3`

### 4. 옵션이 다른 경우
- **입력**: 같은 상품, 다른 옵션 (예: 색상 다름)
- **출력**: 각 옵션별로 1개씩 표시
- **로그**: 중복으로 판단하지 않음

## ⚠️ 주의사항

### 1. 옵션 상품 처리
- 같은 상품이지만 옵션(색상, 사이즈 등)이 다른 경우는 별도 상품으로 취급
- `option_name` 필드가 다르면 중복으로 판단하지 않음

### 2. 가격 변동
- 같은 상품이지만 가격이 다른 경우도 별도 상품으로 취급
- `original_price`, `sale_price`, `discount_rate`가 다르면 중복으로 판단하지 않음

### 3. 순서 보장
- 첫 번째로 등장한 상품을 유지
- `product_order` 필드에 따른 정렬 순서 보존

### 4. 성능 영향
- Set 자료구조 사용으로 O(n) 시간 복잡도
- 상품 수가 많아도 성능 영향 미미 (일반적으로 수십 개 이하)

---

**작성일**: 2025-12-03  
**작성자**: AI Assistant  
**관련 이슈**: 상품 목록에서 동일한 상품이 중복 표시됨  
**버전**: v1.0
